package dataframe

import (
	"fmt"

	"github.com/go-gota/gota/series"
)

// Groups : structure generated by groupby
type Groups struct {
	groups      map[string]DataFrame
	colnames    []string
	aggregation DataFrame
	Err         error
}

// Aggregation :Aggregate dataframe by aggregation type and aggregation column name
func (gps Groups) Aggregation(typs []AggregationType, colnames []string) DataFrame {
	if gps.groups == nil {
		return GotaDataFrame{Err: fmt.Errorf("Aggregation: input is nil")}
	}
	if len(typs) != len(colnames) {
		return GotaDataFrame{Err: fmt.Errorf("Aggregation: len(typs) != len(colanmes)")}
	}
	dfMaps := make([]map[string]interface{}, 0)
	for _, df := range gps.groups {
		targetMap := df.Maps()[0]
		curMap := make(map[string]interface{})
		// add columns of  group by
		for _, c := range gps.colnames {
			if value, ok := targetMap[c]; ok {
				curMap[c] = value
			} else {
				return GotaDataFrame{Err: fmt.Errorf("Aggregation: can't find column name: %s", c)}
			}
		}
		// Aggregation
		for i, c := range colnames {
			curSeries := df.Col(c)
			var value float64
			switch typs[i] {
			case Aggregation_MAX:
				value = curSeries.Max()
			case Aggregation_MEAN:
				value = curSeries.Mean()
			case Aggregation_MEDIAN:
				value = curSeries.Median()
			case Aggregation_MIN:
				value = curSeries.Min()
			case Aggregation_STD:
				value = curSeries.StdDev()
			case Aggregation_SUM:
				value = curSeries.Sum()
			case Aggregation_COUNT:
				value = float64(curSeries.Len())
			default:
				return GotaDataFrame{Err: fmt.Errorf("Aggregation: this method %s not found", typs[i])}

			}
			curMap[fmt.Sprintf("%s_%s", c, typs[i])] = value
		}
		dfMaps = append(dfMaps, curMap)

	}

	// Save column types
	colTypes := map[string]series.Type{}
	for k := range dfMaps[0] {
		switch dfMaps[0][k].(type) {
		case string:
			colTypes[k] = series.String
		case int, int16, int32, int64:
			colTypes[k] = series.Int
		case float32, float64:
			colTypes[k] = series.Float
		default:
			continue
		}
	}

	gps.aggregation = LoadMaps(dfMaps, WithTypes(colTypes))
	return gps.aggregation
}

// GetGroups returns the grouped data frames created by GroupBy
func (g Groups) GetGroups() map[string]DataFrame {
	return g.groups
}
